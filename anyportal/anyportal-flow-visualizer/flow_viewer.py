### flow_viewer v2.1
### Flow field visualizer based on potential flow

### Tested with an Adafruit PyPortal and CircuitPython 6.0.0

### copy this file to MatrixPortal or PyPortal board as code.py

### MIT License

### Copyright (c) 2020 Carter Nelson for Adafruit Industries
### Copyright (c) 2020 Kevin J. Walters

### Permission is hereby granted, free of charge, to any person obtaining a copy
### of this software and associated documentation files (the "Software"), to deal
### in the Software without restriction, including without limitation the rights
### to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
### copies of the Software, and to permit persons to whom the Software is
### furnished to do so, subject to the following conditions:

### The above copyright notice and this permission notice shall be included in all
### copies or substantial portions of the Software.

### THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
### IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
### FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
### AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
### LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
### OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
### SOFTWARE.


#======
# NOTE: Run this on the Matrix Portal or PyPortal.
#======
import time
import math

import board
import displayio

try:
    from adafruit_matrixportal.matrix import Matrix
    matrix_portal = True
except ImportError:
    matrix_portal = False
    print("adafruit_matrixportal.matrix library not present - assuming PyPortal")

try:
    from flow_solution import solution
except ImportError as ex:
    print("A flow_solution.py data file needs to be present - "
          "this is generated by flow_runner")
    raise ex

#--| User Config |-----------------------------------------
BACK_COLOR = 0x000000 # background fill
SOLI_COLOR = 0xADAF00 # solids
HEAD_COLOR = 0x00FFFF # leading particles
TAIL_COLOR = 0x000A0A << (0 if matrix_portal else 3) # trailing particles
TAIL_LENGTH = 10      # length in pixels
DELAY = 0.0           # smaller = faster
#----------------------------------------------------------

# use solution to define other items
VX = solution['VX']
VY = solution['VY']
MATRIX_WIDTH = len(VX[0])
MATRIX_HEIGHT = len(VX)
### Starting locations specified as (x, y)
SEEDS = ((0, y) for y in range(1, MATRIX_HEIGHT - 2, 2))

### Matrix / PyPortal and displayio setup
### PyPortal is 320x240, Titano variant is 480x320, MatrixPortal is 128x64
if matrix_portal:
    matrix = Matrix(width=MATRIX_WIDTH, height=MATRIX_HEIGHT, bit_depth=6)
    display = matrix.display
    solids_bitmap = displayio.Bitmap(display.width, display.height, 4)
    bitmap = displayio.Bitmap(display.width, display.height, 4)
    pix_scale = 1
    group = displayio.Group(max_size=1)
else:
    display = board.DISPLAY
    solids_bitmap = displayio.Bitmap(MATRIX_WIDTH, MATRIX_HEIGHT, 4)
    bitmap = displayio.Bitmap(MATRIX_WIDTH, MATRIX_HEIGHT, 4)
    pix_scale_x = display.width / MATRIX_WIDTH
    pix_scale_y = display.height / MATRIX_HEIGHT
    pix_scale = int(min(pix_scale_x, pix_scale_y))
    group = displayio.Group(max_size=1, scale=pix_scale)
    ### Centre the displayed bitmap
    group.x = (display.width - MATRIX_WIDTH * pix_scale) // 2
    group.y = (display.height - MATRIX_HEIGHT * pix_scale) // 2

display.show(group)

### Draw the solids onto a bitmap used to initialise the frame
for row in range(len(VX)):
    for col, v in enumerate(VX[row]):
        if v is None:
            solids_bitmap[col, row] = 1

palette = displayio.Palette(4)
palette[0] = BACK_COLOR
palette[1] = SOLI_COLOR
palette[2] = HEAD_COLOR
palette[3] = TAIL_COLOR

tile_grid = displayio.TileGrid(bitmap, pixel_shader=palette)
group.append(tile_grid)

# global to store streamline data
STREAMLINES = []


def compute_streamlines():
    '''Compute streamline for each starting point (seed) defined.'''
    for seed in SEEDS:
        streamline = []
        x, y = seed
        px = round(x)
        py = round(y)
        vx = VX[py][px]
        vy = VY[py][px]
        streamline.append( ((px, py), (vx, vy)) )
        steps = 0
        while x < MATRIX_WIDTH and steps < 2 * MATRIX_WIDTH:
            nx = round(x)
            ny = round(y)
            # if we've moved to a new pixel, store the info
            if nx != px or ny != py:
                streamline.append( ((nx, ny), (vx, vy)) )
                px = nx
                py = ny
            if 0 <= nx < MATRIX_WIDTH and 0 <= ny < MATRIX_HEIGHT:
                vx = VX[ny][nx]
                vy = VY[ny][nx]
            if vx is None or vy is None:
                break
            x += vx
            y += vy
            steps += 1
        # add streamline to global store
        STREAMLINES.append(streamline)

def show_streamlines():
    '''Draw the streamlines.'''
    for sl, head in enumerate(HEADS):
        try:
            streamline = STREAMLINES[sl]
            index = round(head)
            length = min(index, TAIL_LENGTH)
            # draw tail
            for data in streamline[index-length:index]:
                x, y = data[0]
                bitmap[round(x), round(y)] = 3
            # draw head
            bitmap[round(x), round(y)] = 2
        except:
            pass # just don't draw it

def animate_streamlines():
    '''Update the current location (head position) along each streamline.'''
    reset_heads = True
    for sl, head in enumerate(HEADS):
        # get associated streamline
        streamline = STREAMLINES[sl]
        # compute index
        index = round(head)
        # get velocity
        if index < len(streamline):
            vx, vy = streamline[index][1]
            reset_heads = False
        else:
            vx, vy = streamline[-1][1]
        # move head
        HEADS[sl] += math.sqrt(vx*vx + vy*vy)
    if reset_heads:
        # all streamlines have reached the end, so reset to start
        for index, _ in enumerate(HEADS):
            HEADS[index] = 0

### fill and redraw bitmap is 11.4ms on Pyportal, blit is 2.6ms
def update_display():
    '''Update the matrix display.'''
    display.auto_refresh = False
    bitmap.blit(0, 0, solids_bitmap)
    show_streamlines()
    display.auto_refresh = True

#==========
# MAIN
#==========
print('Computing streamlines...', end='')
compute_streamlines()
print('DONE')
HEADS = [0]*len(STREAMLINES)
print('Flowing...')
while True:
    animate_streamlines()
    update_display()
    time.sleep(DELAY)
